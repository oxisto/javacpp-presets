// Targeted by JavaCPP version 1.5.7-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.treesitter.global;

import org.bytedeco.treesitter.*;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

public class treesitter extends org.bytedeco.treesitter.presets.treesitter {
    static { Loader.load(); }

// Parsed from <tree_sitter/parser.h>

// #ifndef TREE_SITTER_PARSER_H_
// #define TREE_SITTER_PARSER_H_

// #ifdef __cplusplus
// #endif

// #include <stdbool.h>
// #include <stdint.h>
// #include <stdlib.h>

public static native @MemberGetter @Cast("uint16_t") short ts_builtin_sym_error();
public static final short ts_builtin_sym_error = ts_builtin_sym_error();
public static final int ts_builtin_sym_end = 0;
public static final int TREE_SITTER_SERIALIZATION_BUFFER_SIZE = 1024;

// #ifndef TREE_SITTER_API_H_
// Targeting ../TSFieldMapEntry.java


// Targeting ../TSFieldMapSlice.java


// Targeting ../TSSymbolMetadata.java


// Targeting ../TSLexer.java



/** enum TSParseActionType */
public static final int
  TSParseActionTypeShift = 0,
  TSParseActionTypeReduce = 1,
  TSParseActionTypeAccept = 2,
  TSParseActionTypeRecover = 3;
// Targeting ../TSParseAction.java


// Targeting ../TSLexMode.java


// Targeting ../TSParseActionEntry.java


// Targeting ../TSLanguage.java



/*
 *  Lexer Macros
 */

// #define START_LEXER()
//   bool result = false;
//   bool skip = false;
//   bool eof = false;
//   int32_t lookahead;
//   goto start;
//   next_state:
//   lexer->advance(lexer, skip);
//   start:
//   skip = false;
//   lookahead = lexer->lookahead;

// #define ADVANCE(state_value)
//   {
//     state = state_value;
//     goto next_state;
//   }

// #define SKIP(state_value)
//   {
//     skip = true;
//     state = state_value;
//     goto next_state;
//   }

// #define ACCEPT_TOKEN(symbol_value)
//   result = true;
//   lexer->result_symbol = symbol_value;
//   lexer->mark_end(lexer);

// #define END_STATE() return result;

/*
 *  Parse Table Macros
 */

// #define SMALL_STATE(id) id - LARGE_STATE_COUNT

// #define STATE(id) id

// #define ACTIONS(id) id

// #define SHIFT(state_value)
//   {{
//     .shift = {
//       .type = TSParseActionTypeShift,
//       .state = state_value
//     }
//   }}

// #define SHIFT_REPEAT(state_value)
//   {{
//     .shift = {
//       .type = TSParseActionTypeShift,
//       .state = state_value,
//       .repetition = true
//     }
//   }}

// #define SHIFT_EXTRA()
//   {{
//     .shift = {
//       .type = TSParseActionTypeShift,
//       .extra = true
//     }
//   }}

// #define REDUCE(symbol_val, child_count_val, ...)
//   {{
//     .reduce = {
//       .type = TSParseActionTypeReduce,
//       .symbol = symbol_val,
//       .child_count = child_count_val,
//       __VA_ARGS__
//     },
//   }}

// #define RECOVER()
//   {{
//     .type = TSParseActionTypeRecover
//   }}

// #define ACCEPT_INPUT()
//   {{
//     .type = TSParseActionTypeAccept
//   }}

// #ifdef __cplusplus
// #endif

// #endif  // TREE_SITTER_PARSER_H_


// Parsed from <tree_sitter/api.h>

// #ifndef TREE_SITTER_API_H_
// #define TREE_SITTER_API_H_

// #ifdef __cplusplus
// #endif

// #include <stdio.h>
// #include <stdlib.h>
// #include <stdint.h>
// #include <stdbool.h>

/****************************/
/* Section - ABI Versioning */
/****************************/

/**
 * The latest ABI version that is supported by the current version of the
 * library. When Languages are generated by the Tree-sitter CLI, they are
 * assigned an ABI version number that corresponds to the current CLI version.
 * The Tree-sitter library is generally backwards-compatible with languages
 * generated using older CLI versions, but is not forwards-compatible.
 */
public static final int TREE_SITTER_LANGUAGE_VERSION = 13;

/**
 * The earliest ABI version that is supported by the current version of the
 * library.
 */
public static final int TREE_SITTER_MIN_COMPATIBLE_LANGUAGE_VERSION = 13;

/*******************/
/* Section - Types */
/*******************/
// Targeting ../TSParser.java


// Targeting ../TSTree.java


// Targeting ../TSQuery.java


// Targeting ../TSQueryCursor.java



/** enum TSInputEncoding */
public static final int
  TSInputEncodingUTF8 = 0,
  TSInputEncodingUTF16 = 1;

/** enum TSSymbolType */
public static final int
  TSSymbolTypeRegular = 0,
  TSSymbolTypeAnonymous = 1,
  TSSymbolTypeAuxiliary = 2;
// Targeting ../TSPoint.java


// Targeting ../TSRange.java


// Targeting ../TSInput.java



/** enum TSLogType */
public static final int
  TSLogTypeParse = 0,
  TSLogTypeLex = 1;
// Targeting ../TSLogger.java


// Targeting ../TSInputEdit.java


// Targeting ../TSNode.java


// Targeting ../TSTreeCursor.java


// Targeting ../TSQueryCapture.java


// Targeting ../TSQueryMatch.java



/** enum TSQueryPredicateStepType */
public static final int
  TSQueryPredicateStepTypeDone = 0,
  TSQueryPredicateStepTypeCapture = 1,
  TSQueryPredicateStepTypeString = 2;
// Targeting ../TSQueryPredicateStep.java



/** enum TSQueryError */
public static final int
  TSQueryErrorNone = 0,
  TSQueryErrorSyntax = 1,
  TSQueryErrorNodeType = 2,
  TSQueryErrorField = 3,
  TSQueryErrorCapture = 4,
  TSQueryErrorStructure = 5;

/********************/
/* Section - Parser */
/********************/

/**
 * Create a new parser.
 */
public static native TSParser ts_parser_new();

/**
 * Delete the parser, freeing all of the memory that it used.
 */
public static native void ts_parser_delete(TSParser parser);

/**
 * Set the language that the parser should use for parsing.
 *
 * Returns a boolean indicating whether or not the language was successfully
 * assigned. True means assignment succeeded. False means there was a version
 * mismatch: the language was generated with an incompatible version of the
 * Tree-sitter CLI. Check the language's version using {@code ts_language_version}
 * and compare it to this library's {@code TREE_SITTER_LANGUAGE_VERSION} and
 * {@code TREE_SITTER_MIN_COMPATIBLE_LANGUAGE_VERSION} constants.
 */
public static native @Cast("bool") boolean ts_parser_set_language(TSParser self, @Const TSLanguage language);

/**
 * Get the parser's current language.
 */
public static native @Const TSLanguage ts_parser_language(@Const TSParser self);

/**
 * Set the ranges of text that the parser should include when parsing.
 *
 * By default, the parser will always include entire documents. This function
 * allows you to parse only a *portion* of a document but still return a syntax
 * tree whose ranges match up with the document as a whole. You can also pass
 * multiple disjoint ranges.
 *
 * The second and third parameters specify the location and length of an array
 * of ranges. The parser does *not* take ownership of these ranges; it copies
 * the data, so it doesn't matter how these ranges are allocated.
 *
 * If {@code length} is zero, then the entire document will be parsed. Otherwise,
 * the given ranges must be ordered from earliest to latest in the document,
 * and they must not overlap. That is, the following must hold for all
 * {@code i} < {@code length - 1}:
 *
 *     ranges[i].end_byte <= ranges[i + 1].start_byte
 *
 * If this requirement is not satisfied, the operation will fail, the ranges
 * will not be assigned, and this function will return {@code false}. On success,
 * this function returns {@code true}
 */
public static native @Cast("bool") boolean ts_parser_set_included_ranges(
  TSParser self,
  @Const TSRange ranges,
  @Cast("uint32_t") int length
);

/**
 * Get the ranges of text that the parser will include when parsing.
 *
 * The returned pointer is owned by the parser. The caller should not free it
 * or write to it. The length of the array will be written to the given
 * {@code length} pointer.
 */
public static native @Const TSRange ts_parser_included_ranges(
  @Const TSParser self,
  @Cast("uint32_t*") IntPointer length
);
public static native @Const TSRange ts_parser_included_ranges(
  @Const TSParser self,
  @Cast("uint32_t*") IntBuffer length
);
public static native @Const TSRange ts_parser_included_ranges(
  @Const TSParser self,
  @Cast("uint32_t*") int[] length
);

/**
 * Use the parser to parse some source code and create a syntax tree.
 *
 * If you are parsing this document for the first time, pass {@code NULL} for the
 * {@code old_tree} parameter. Otherwise, if you have already parsed an earlier
 * version of this document and the document has since been edited, pass the
 * previous syntax tree so that the unchanged parts of it can be reused.
 * This will save time and memory. For this to work correctly, you must have
 * already edited the old syntax tree using the {@code ts_tree_edit} function in a
 * way that exactly matches the source code changes.
 *
 * The {@code TSInput} parameter lets you specify how to read the text. It has the
 * following three fields:
 * 1. {@code read}: A function to retrieve a chunk of text at a given byte offset
 *    and (row, column) position. The function should return a pointer to the
 *    text and write its length to the {@code bytes_read} pointer. The parser does
 *    not take ownership of this buffer; it just borrows it until it has
 *    finished reading it. The function should write a zero value to the
 *    {@code bytes_read} pointer to indicate the end of the document.
 * 2. {@code payload}: An arbitrary pointer that will be passed to each invocation
 *    of the {@code read} function.
 * 3. {@code encoding}: An indication of how the text is encoded. Either
 *    {@code TSInputEncodingUTF8} or {@code TSInputEncodingUTF16}.
 *
 * This function returns a syntax tree on success, and {@code NULL} on failure. There
 * are three possible reasons for failure:
 * 1. The parser does not have a language assigned. Check for this using the
      {@code ts_parser_language} function.
 * 2. Parsing was cancelled due to a timeout that was set by an earlier call to
 *    the {@code ts_parser_set_timeout_micros} function. You can resume parsing from
 *    where the parser left out by calling {@code ts_parser_parse} again with the
 *    same arguments. Or you can start parsing from scratch by first calling
 *    {@code ts_parser_reset}.
 * 3. Parsing was cancelled using a cancellation flag that was set by an
 *    earlier call to {@code ts_parser_set_cancellation_flag}. You can resume parsing
 *    from where the parser left out by calling {@code ts_parser_parse} again with
 *    the same arguments.
 */
public static native TSTree ts_parser_parse(
  TSParser self,
  @Const TSTree old_tree,
  @ByVal TSInput input
);

/**
 * Use the parser to parse some source code stored in one contiguous buffer.
 * The first two parameters are the same as in the {@code ts_parser_parse} function
 * above. The second two parameters indicate the location of the buffer and its
 * length in bytes.
 */
public static native TSTree ts_parser_parse_string(
  TSParser self,
  @Const TSTree old_tree,
  @Cast("const char*") BytePointer string,
  @Cast("uint32_t") int length
);
public static native TSTree ts_parser_parse_string(
  TSParser self,
  @Const TSTree old_tree,
  String string,
  @Cast("uint32_t") int length
);

/**
 * Use the parser to parse some source code stored in one contiguous buffer with
 * a given encoding. The first four parameters work the same as in the
 * {@code ts_parser_parse_string} method above. The final parameter indicates whether
 * the text is encoded as UTF8 or UTF16.
 */
public static native TSTree ts_parser_parse_string_encoding(
  TSParser self,
  @Const TSTree old_tree,
  @Cast("const char*") BytePointer string,
  @Cast("uint32_t") int length,
  @Cast("TSInputEncoding") int encoding
);
public static native TSTree ts_parser_parse_string_encoding(
  TSParser self,
  @Const TSTree old_tree,
  String string,
  @Cast("uint32_t") int length,
  @Cast("TSInputEncoding") int encoding
);

/**
 * Instruct the parser to start the next parse from the beginning.
 *
 * If the parser previously failed because of a timeout or a cancellation, then
 * by default, it will resume where it left off on the next call to
 * {@code ts_parser_parse} or other parsing functions. If you don't want to resume,
 * and instead intend to use this parser to parse some other document, you must
 * call {@code ts_parser_reset} first.
 */
public static native void ts_parser_reset(TSParser self);

/**
 * Set the maximum duration in microseconds that parsing should be allowed to
 * take before halting.
 *
 * If parsing takes longer than this, it will halt early, returning NULL.
 * See {@code ts_parser_parse} for more information.
 */
public static native void ts_parser_set_timeout_micros(TSParser self, @Cast("uint64_t") long timeout);

/**
 * Get the duration in microseconds that parsing is allowed to take.
 */
public static native @Cast("uint64_t") long ts_parser_timeout_micros(@Const TSParser self);

/**
 * Set the parser's current cancellation flag pointer.
 *
 * If a non-null pointer is assigned, then the parser will periodically read
 * from this pointer during parsing. If it reads a non-zero value, it will
 * halt early, returning NULL. See {@code ts_parser_parse} for more information.
 */
public static native void ts_parser_set_cancellation_flag(TSParser self, @Cast("const size_t*") SizeTPointer flag);

/**
 * Get the parser's current cancellation flag pointer.
 */
public static native @Cast("const size_t*") SizeTPointer ts_parser_cancellation_flag(@Const TSParser self);

/**
 * Set the logger that a parser should use during parsing.
 *
 * The parser does not take ownership over the logger payload. If a logger was
 * previously assigned, the caller is responsible for releasing any memory
 * owned by the previous logger.
 */
public static native void ts_parser_set_logger(TSParser self, @ByVal TSLogger logger);

/**
 * Get the parser's current logger.
 */
public static native @ByVal TSLogger ts_parser_logger(@Const TSParser self);

/**
 * Set the file descriptor to which the parser should write debugging graphs
 * during parsing. The graphs are formatted in the DOT language. You may want
 * to pipe these graphs directly to a {@code dot(1)} process in order to generate
 * SVG output. You can turn off this logging by passing a negative number.
 */
public static native void ts_parser_print_dot_graphs(TSParser self, int file);

/******************/
/* Section - Tree */
/******************/

/**
 * Create a shallow copy of the syntax tree. This is very fast.
 *
 * You need to copy a syntax tree in order to use it on more than one thread at
 * a time, as syntax trees are not thread safe.
 */
public static native TSTree ts_tree_copy(@Const TSTree self);

/**
 * Delete the syntax tree, freeing all of the memory that it used.
 */
public static native void ts_tree_delete(TSTree self);

/**
 * Get the root node of the syntax tree.
 */
public static native @ByVal TSNode ts_tree_root_node(@Const TSTree self);

/**
 * Get the language that was used to parse the syntax tree.
 */
public static native @Const TSLanguage ts_tree_language(@Const TSTree arg0);

/**
 * Edit the syntax tree to keep it in sync with source code that has been
 * edited.
 *
 * You must describe the edit both in terms of byte offsets and in terms of
 * (row, column) coordinates.
 */
public static native void ts_tree_edit(TSTree self, @Const TSInputEdit edit);

/**
 * Compare an old edited syntax tree to a new syntax tree representing the same
 * document, returning an array of ranges whose syntactic structure has changed.
 *
 * For this to work correctly, the old syntax tree must have been edited such
 * that its ranges match up to the new tree. Generally, you'll want to call
 * this function right after calling one of the {@code ts_parser_parse} functions.
 * You need to pass the old tree that was passed to parse, as well as the new
 * tree that was returned from that function.
 *
 * The returned array is allocated using {@code malloc} and the caller is responsible
 * for freeing it using {@code free}. The length of the array will be written to the
 * given {@code length} pointer.
 */
public static native TSRange ts_tree_get_changed_ranges(
  @Const TSTree old_tree,
  @Const TSTree new_tree,
  @Cast("uint32_t*") IntPointer length
);
public static native TSRange ts_tree_get_changed_ranges(
  @Const TSTree old_tree,
  @Const TSTree new_tree,
  @Cast("uint32_t*") IntBuffer length
);
public static native TSRange ts_tree_get_changed_ranges(
  @Const TSTree old_tree,
  @Const TSTree new_tree,
  @Cast("uint32_t*") int[] length
);

/**
 * Write a DOT graph describing the syntax tree to the given file.
 */
public static native void ts_tree_print_dot_graph(@Const TSTree arg0, @Cast("FILE*") Pointer arg1);

/******************/
/* Section - Node */
/******************/

/**
 * Get the node's type as a null-terminated string.
 */
public static native @Cast("const char*") BytePointer ts_node_type(@ByVal TSNode arg0);

/**
 * Get the node's type as a numerical id.
 */
public static native @Cast("uint16_t") short ts_node_symbol(@ByVal TSNode arg0);

/**
 * Get the node's start byte.
 */
public static native @Cast("uint32_t") int ts_node_start_byte(@ByVal TSNode arg0);

/**
 * Get the node's start position in terms of rows and columns.
 */
public static native @ByVal TSPoint ts_node_start_point(@ByVal TSNode arg0);

/**
 * Get the node's end byte.
 */
public static native @Cast("uint32_t") int ts_node_end_byte(@ByVal TSNode arg0);

/**
 * Get the node's end position in terms of rows and columns.
 */
public static native @ByVal TSPoint ts_node_end_point(@ByVal TSNode arg0);

/**
 * Get an S-expression representing the node as a string.
 *
 * This string is allocated with {@code malloc} and the caller is responsible for
 * freeing it using {@code free}.
 */
public static native @Cast("char*") BytePointer ts_node_string(@ByVal TSNode arg0);

/**
 * Check if the node is null. Functions like {@code ts_node_child} and
 * {@code ts_node_next_sibling} will return a null node to indicate that no such node
 * was found.
 */
public static native @Cast("bool") boolean ts_node_is_null(@ByVal TSNode arg0);

/**
 * Check if the node is *named*. Named nodes correspond to named rules in the
 * grammar, whereas *anonymous* nodes correspond to string literals in the
 * grammar.
 */
public static native @Cast("bool") boolean ts_node_is_named(@ByVal TSNode arg0);

/**
 * Check if the node is *missing*. Missing nodes are inserted by the parser in
 * order to recover from certain kinds of syntax errors.
 */
public static native @Cast("bool") boolean ts_node_is_missing(@ByVal TSNode arg0);

/**
 * Check if the node is *extra*. Extra nodes represent things like comments,
 * which are not required the grammar, but can appear anywhere.
 */
public static native @Cast("bool") boolean ts_node_is_extra(@ByVal TSNode arg0);

/**
 * Check if a syntax node has been edited.
 */
public static native @Cast("bool") boolean ts_node_has_changes(@ByVal TSNode arg0);

/**
 * Check if the node is a syntax error or contains any syntax errors.
 */
public static native @Cast("bool") boolean ts_node_has_error(@ByVal TSNode arg0);

/**
 * Get the node's immediate parent.
 */
public static native @ByVal TSNode ts_node_parent(@ByVal TSNode arg0);

/**
 * Get the node's child at the given index, where zero represents the first
 * child.
 */
public static native @ByVal TSNode ts_node_child(@ByVal TSNode arg0, @Cast("uint32_t") int arg1);

/**
 * Get the field name for node's child at the given index, where zero represents
 * the first child. Returns NULL, if no field is found.
 */
public static native @Cast("const char*") BytePointer ts_node_field_name_for_child(@ByVal TSNode arg0, @Cast("uint32_t") int arg1);

/**
 * Get the node's number of children.
 */
public static native @Cast("uint32_t") int ts_node_child_count(@ByVal TSNode arg0);

/**
 * Get the node's *named* child at the given index.
 *
 * See also {@code ts_node_is_named}.
 */
public static native @ByVal TSNode ts_node_named_child(@ByVal TSNode arg0, @Cast("uint32_t") int arg1);

/**
 * Get the node's number of *named* children.
 *
 * See also {@code ts_node_is_named}.
 */
public static native @Cast("uint32_t") int ts_node_named_child_count(@ByVal TSNode arg0);

/**
 * Get the node's child with the given field name.
 */
public static native @ByVal TSNode ts_node_child_by_field_name(
  @ByVal TSNode self,
  @Cast("const char*") BytePointer field_name,
  @Cast("uint32_t") int field_name_length
);
public static native @ByVal TSNode ts_node_child_by_field_name(
  @ByVal TSNode self,
  String field_name,
  @Cast("uint32_t") int field_name_length
);

/**
 * Get the node's child with the given numerical field id.
 *
 * You can convert a field name to an id using the
 * {@code ts_language_field_id_for_name} function.
 */
public static native @ByVal TSNode ts_node_child_by_field_id(@ByVal TSNode arg0, @Cast("TSFieldId") short arg1);

/**
 * Get the node's next / previous sibling.
 */
public static native @ByVal TSNode ts_node_next_sibling(@ByVal TSNode arg0);
public static native @ByVal TSNode ts_node_prev_sibling(@ByVal TSNode arg0);

/**
 * Get the node's next / previous *named* sibling.
 */
public static native @ByVal TSNode ts_node_next_named_sibling(@ByVal TSNode arg0);
public static native @ByVal TSNode ts_node_prev_named_sibling(@ByVal TSNode arg0);

/**
 * Get the node's first child that extends beyond the given byte offset.
 */
public static native @ByVal TSNode ts_node_first_child_for_byte(@ByVal TSNode arg0, @Cast("uint32_t") int arg1);

/**
 * Get the node's first named child that extends beyond the given byte offset.
 */
public static native @ByVal TSNode ts_node_first_named_child_for_byte(@ByVal TSNode arg0, @Cast("uint32_t") int arg1);

/**
 * Get the smallest node within this node that spans the given range of bytes
 * or (row, column) positions.
 */
public static native @ByVal TSNode ts_node_descendant_for_byte_range(@ByVal TSNode arg0, @Cast("uint32_t") int arg1, @Cast("uint32_t") int arg2);
public static native @ByVal TSNode ts_node_descendant_for_point_range(@ByVal TSNode arg0, @ByVal TSPoint arg1, @ByVal TSPoint arg2);

/**
 * Get the smallest named node within this node that spans the given range of
 * bytes or (row, column) positions.
 */
public static native @ByVal TSNode ts_node_named_descendant_for_byte_range(@ByVal TSNode arg0, @Cast("uint32_t") int arg1, @Cast("uint32_t") int arg2);
public static native @ByVal TSNode ts_node_named_descendant_for_point_range(@ByVal TSNode arg0, @ByVal TSPoint arg1, @ByVal TSPoint arg2);

/**
 * Edit the node to keep it in-sync with source code that has been edited.
 *
 * This function is only rarely needed. When you edit a syntax tree with the
 * {@code ts_tree_edit} function, all of the nodes that you retrieve from the tree
 * afterward will already reflect the edit. You only need to use {@code ts_node_edit}
 * when you have a {@code TSNode} instance that you want to keep and continue to use
 * after an edit.
 */
public static native void ts_node_edit(TSNode arg0, @Const TSInputEdit arg1);

/**
 * Check if two nodes are identical.
 */
public static native @Cast("bool") boolean ts_node_eq(@ByVal TSNode arg0, @ByVal TSNode arg1);

/************************/
/* Section - TreeCursor */
/************************/

/**
 * Create a new tree cursor starting from the given node.
 *
 * A tree cursor allows you to walk a syntax tree more efficiently than is
 * possible using the {@code TSNode} functions. It is a mutable object that is always
 * on a certain syntax node, and can be moved imperatively to different nodes.
 */
public static native @ByVal TSTreeCursor ts_tree_cursor_new(@ByVal TSNode arg0);

/**
 * Delete a tree cursor, freeing all of the memory that it used.
 */
public static native void ts_tree_cursor_delete(TSTreeCursor arg0);

/**
 * Re-initialize a tree cursor to start at a different node.
 */
public static native void ts_tree_cursor_reset(TSTreeCursor arg0, @ByVal TSNode arg1);

/**
 * Get the tree cursor's current node.
 */
public static native @ByVal TSNode ts_tree_cursor_current_node(@Const TSTreeCursor arg0);

/**
 * Get the field name of the tree cursor's current node.
 *
 * This returns {@code NULL} if the current node doesn't have a field.
 * See also {@code ts_node_child_by_field_name}.
 */
public static native @Cast("const char*") BytePointer ts_tree_cursor_current_field_name(@Const TSTreeCursor arg0);

/**
 * Get the field name of the tree cursor's current node.
 *
 * This returns zero if the current node doesn't have a field.
 * See also {@code ts_node_child_by_field_id}, {@code ts_language_field_id_for_name}.
 */
public static native @Cast("TSFieldId") short ts_tree_cursor_current_field_id(@Const TSTreeCursor arg0);

/**
 * Move the cursor to the parent of its current node.
 *
 * This returns {@code true} if the cursor successfully moved, and returns {@code false}
 * if there was no parent node (the cursor was already on the root node).
 */
public static native @Cast("bool") boolean ts_tree_cursor_goto_parent(TSTreeCursor arg0);

/**
 * Move the cursor to the next sibling of its current node.
 *
 * This returns {@code true} if the cursor successfully moved, and returns {@code false}
 * if there was no next sibling node.
 */
public static native @Cast("bool") boolean ts_tree_cursor_goto_next_sibling(TSTreeCursor arg0);

/**
 * Move the cursor to the first child of its current node.
 *
 * This returns {@code true} if the cursor successfully moved, and returns {@code false}
 * if there were no children.
 */
public static native @Cast("bool") boolean ts_tree_cursor_goto_first_child(TSTreeCursor arg0);

/**
 * Move the cursor to the first child of its current node that extends beyond
 * the given byte offset or point.
 *
 * This returns the index of the child node if one was found, and returns -1
 * if no such child was found.
 */
public static native @Cast("int64_t") long ts_tree_cursor_goto_first_child_for_byte(TSTreeCursor arg0, @Cast("uint32_t") int arg1);
public static native @Cast("int64_t") long ts_tree_cursor_goto_first_child_for_point(TSTreeCursor arg0, @ByVal TSPoint arg1);

public static native @ByVal TSTreeCursor ts_tree_cursor_copy(@Const TSTreeCursor arg0);

/*******************/
/* Section - Query */
/*******************/

/**
 * Create a new query from a string containing one or more S-expression
 * patterns. The query is associated with a particular language, and can
 * only be run on syntax nodes parsed with that language.
 *
 * If all of the given patterns are valid, this returns a {@code TSQuery}.
 * If a pattern is invalid, this returns {@code NULL}, and provides two pieces
 * of information about the problem:
 * 1. The byte offset of the error is written to the {@code error_offset} parameter.
 * 2. The type of error is written to the {@code error_type} parameter.
 */
public static native TSQuery ts_query_new(
  @Const TSLanguage language,
  @Cast("const char*") BytePointer source,
  @Cast("uint32_t") int source_len,
  @Cast("uint32_t*") IntPointer error_offset,
  @Cast("TSQueryError*") IntPointer error_type
);
public static native TSQuery ts_query_new(
  @Const TSLanguage language,
  String source,
  @Cast("uint32_t") int source_len,
  @Cast("uint32_t*") IntBuffer error_offset,
  @Cast("TSQueryError*") IntBuffer error_type
);
public static native TSQuery ts_query_new(
  @Const TSLanguage language,
  @Cast("const char*") BytePointer source,
  @Cast("uint32_t") int source_len,
  @Cast("uint32_t*") int[] error_offset,
  @Cast("TSQueryError*") int[] error_type
);
public static native TSQuery ts_query_new(
  @Const TSLanguage language,
  String source,
  @Cast("uint32_t") int source_len,
  @Cast("uint32_t*") IntPointer error_offset,
  @Cast("TSQueryError*") IntPointer error_type
);
public static native TSQuery ts_query_new(
  @Const TSLanguage language,
  @Cast("const char*") BytePointer source,
  @Cast("uint32_t") int source_len,
  @Cast("uint32_t*") IntBuffer error_offset,
  @Cast("TSQueryError*") IntBuffer error_type
);
public static native TSQuery ts_query_new(
  @Const TSLanguage language,
  String source,
  @Cast("uint32_t") int source_len,
  @Cast("uint32_t*") int[] error_offset,
  @Cast("TSQueryError*") int[] error_type
);

/**
 * Delete a query, freeing all of the memory that it used.
 */
public static native void ts_query_delete(TSQuery arg0);

/**
 * Get the number of patterns, captures, or string literals in the query.
 */
public static native @Cast("uint32_t") int ts_query_pattern_count(@Const TSQuery arg0);
public static native @Cast("uint32_t") int ts_query_capture_count(@Const TSQuery arg0);
public static native @Cast("uint32_t") int ts_query_string_count(@Const TSQuery arg0);

/**
 * Get the byte offset where the given pattern starts in the query's source.
 *
 * This can be useful when combining queries by concatenating their source
 * code strings.
 */
public static native @Cast("uint32_t") int ts_query_start_byte_for_pattern(@Const TSQuery arg0, @Cast("uint32_t") int arg1);

/**
 * Get all of the predicates for the given pattern in the query.
 *
 * The predicates are represented as a single array of steps. There are three
 * types of steps in this array, which correspond to the three legal values for
 * the {@code type} field:
 * - {@code TSQueryPredicateStepTypeCapture} - Steps with this type represent names
 *    of captures. Their {@code value_id} can be used with the
 *   {@code ts_query_capture_name_for_id} function to obtain the name of the capture.
 * - {@code TSQueryPredicateStepTypeString} - Steps with this type represent literal
 *    strings. Their {@code value_id} can be used with the
 *    {@code ts_query_string_value_for_id} function to obtain their string value.
 * - {@code TSQueryPredicateStepTypeDone} - Steps with this type are *sentinels*
 *    that represent the end of an individual predicate. If a pattern has two
 *    predicates, then there will be two steps with this {@code type} in the array.
 */
public static native @Const TSQueryPredicateStep ts_query_predicates_for_pattern(
  @Const TSQuery self,
  @Cast("uint32_t") int pattern_index,
  @Cast("uint32_t*") IntPointer length
);
public static native @Const TSQueryPredicateStep ts_query_predicates_for_pattern(
  @Const TSQuery self,
  @Cast("uint32_t") int pattern_index,
  @Cast("uint32_t*") IntBuffer length
);
public static native @Const TSQueryPredicateStep ts_query_predicates_for_pattern(
  @Const TSQuery self,
  @Cast("uint32_t") int pattern_index,
  @Cast("uint32_t*") int[] length
);

public static native @Cast("bool") boolean ts_query_step_is_definite(
  @Const TSQuery self,
  @Cast("uint32_t") int byte_offset
);

/**
 * Get the name and length of one of the query's captures, or one of the
 * query's string literals. Each capture and string is associated with a
 * numeric id based on the order that it appeared in the query's source.
 */
public static native @Cast("const char*") BytePointer ts_query_capture_name_for_id(
  @Const TSQuery arg0,
  @Cast("uint32_t") int id,
  @Cast("uint32_t*") IntPointer length
);
public static native String ts_query_capture_name_for_id(
  @Const TSQuery arg0,
  @Cast("uint32_t") int id,
  @Cast("uint32_t*") IntBuffer length
);
public static native @Cast("const char*") BytePointer ts_query_capture_name_for_id(
  @Const TSQuery arg0,
  @Cast("uint32_t") int id,
  @Cast("uint32_t*") int[] length
);
public static native @Cast("const char*") BytePointer ts_query_string_value_for_id(
  @Const TSQuery arg0,
  @Cast("uint32_t") int id,
  @Cast("uint32_t*") IntPointer length
);
public static native String ts_query_string_value_for_id(
  @Const TSQuery arg0,
  @Cast("uint32_t") int id,
  @Cast("uint32_t*") IntBuffer length
);
public static native @Cast("const char*") BytePointer ts_query_string_value_for_id(
  @Const TSQuery arg0,
  @Cast("uint32_t") int id,
  @Cast("uint32_t*") int[] length
);

/**
 * Disable a certain capture within a query.
 *
 * This prevents the capture from being returned in matches, and also avoids
 * any resource usage associated with recording the capture. Currently, there
 * is no way to undo this.
 */
public static native void ts_query_disable_capture(TSQuery arg0, @Cast("const char*") BytePointer arg1, @Cast("uint32_t") int arg2);
public static native void ts_query_disable_capture(TSQuery arg0, String arg1, @Cast("uint32_t") int arg2);

/**
 * Disable a certain pattern within a query.
 *
 * This prevents the pattern from matching and removes most of the overhead
 * associated with the pattern. Currently, there is no way to undo this.
 */
public static native void ts_query_disable_pattern(TSQuery arg0, @Cast("uint32_t") int arg1);

/**
 * Create a new cursor for executing a given query.
 *
 * The cursor stores the state that is needed to iteratively search
 * for matches. To use the query cursor, first call {@code ts_query_cursor_exec}
 * to start running a given query on a given syntax node. Then, there are
 * two options for consuming the results of the query:
 * 1. Repeatedly call {@code ts_query_cursor_next_match} to iterate over all of the
 *    *matches* in the order that they were found. Each match contains the
 *    index of the pattern that matched, and an array of captures. Because
 *    multiple patterns can match the same set of nodes, one match may contain
 *    captures that appear *before* some of the captures from a previous match.
 * 2. Repeatedly call {@code ts_query_cursor_next_capture} to iterate over all of the
 *    individual *captures* in the order that they appear. This is useful if
 *    don't care about which pattern matched, and just want a single ordered
 *    sequence of captures.
 *
 * If you don't care about consuming all of the results, you can stop calling
 * {@code ts_query_cursor_next_match} or {@code ts_query_cursor_next_capture} at any point.
 *  You can then start executing another query on another node by calling
 *  {@code ts_query_cursor_exec} again.
 */
public static native TSQueryCursor ts_query_cursor_new();

/**
 * Delete a query cursor, freeing all of the memory that it used.
 */
public static native void ts_query_cursor_delete(TSQueryCursor arg0);

/**
 * Start running a given query on a given node.
 */
public static native void ts_query_cursor_exec(TSQueryCursor arg0, @Const TSQuery arg1, @ByVal TSNode arg2);

/**
 * Manage the maximum number of in-progress matches allowed by this query
 * cursor.
 *
 * Query cursors have an optional maximum capacity for storing lists of
 * in-progress captures. If this capacity is exceeded, then the
 * earliest-starting match will silently be dropped to make room for further
 * matches. This maximum capacity is optional â€” by default, query cursors allow
 * any number of pending matches, dynamically allocating new space for them as
 * needed as the query is executed.
 */
public static native @Cast("bool") boolean ts_query_cursor_did_exceed_match_limit(@Const TSQueryCursor arg0);
public static native @Cast("uint32_t") int ts_query_cursor_match_limit(@Const TSQueryCursor arg0);
public static native void ts_query_cursor_set_match_limit(TSQueryCursor arg0, @Cast("uint32_t") int arg1);

/**
 * Set the range of bytes or (row, column) positions in which the query
 * will be executed.
 */
public static native void ts_query_cursor_set_byte_range(TSQueryCursor arg0, @Cast("uint32_t") int arg1, @Cast("uint32_t") int arg2);
public static native void ts_query_cursor_set_point_range(TSQueryCursor arg0, @ByVal TSPoint arg1, @ByVal TSPoint arg2);

/**
 * Advance to the next match of the currently running query.
 *
 * If there is a match, write it to {@code *match} and return {@code true}.
 * Otherwise, return {@code false}.
 */
public static native @Cast("bool") boolean ts_query_cursor_next_match(TSQueryCursor arg0, TSQueryMatch match);
public static native void ts_query_cursor_remove_match(TSQueryCursor arg0, @Cast("uint32_t") int id);

/**
 * Advance to the next capture of the currently running query.
 *
 * If there is a capture, write its match to {@code *match} and its index within
 * the matche's capture list to {@code *capture_index}. Otherwise, return {@code false}.
 */
public static native @Cast("bool") boolean ts_query_cursor_next_capture(
  TSQueryCursor arg0,
  TSQueryMatch match,
  @Cast("uint32_t*") IntPointer capture_index
);
public static native @Cast("bool") boolean ts_query_cursor_next_capture(
  TSQueryCursor arg0,
  TSQueryMatch match,
  @Cast("uint32_t*") IntBuffer capture_index
);
public static native @Cast("bool") boolean ts_query_cursor_next_capture(
  TSQueryCursor arg0,
  TSQueryMatch match,
  @Cast("uint32_t*") int[] capture_index
);

/**********************/
/* Section - Language */
/**********************/

/**
 * Get the number of distinct node types in the language.
 */
public static native @Cast("uint32_t") int ts_language_symbol_count(@Const TSLanguage arg0);

/**
 * Get a node type string for the given numerical id.
 */
public static native @Cast("const char*") BytePointer ts_language_symbol_name(@Const TSLanguage arg0, @Cast("uint16_t") short arg1);

/**
 * Get the numerical id for the given node type string.
 */
public static native @Cast("uint16_t") short ts_language_symbol_for_name(
  @Const TSLanguage self,
  @Cast("const char*") BytePointer string,
  @Cast("uint32_t") int length,
  @Cast("bool") boolean is_named
);
public static native @Cast("uint16_t") short ts_language_symbol_for_name(
  @Const TSLanguage self,
  String string,
  @Cast("uint32_t") int length,
  @Cast("bool") boolean is_named
);

/**
 * Get the number of distinct field names in the language.
 */
public static native @Cast("uint32_t") int ts_language_field_count(@Const TSLanguage arg0);

/**
 * Get the field name string for the given numerical id.
 */
public static native @Cast("const char*") BytePointer ts_language_field_name_for_id(@Const TSLanguage arg0, @Cast("TSFieldId") short arg1);

/**
 * Get the numerical id for the given field name string.
 */
public static native @Cast("TSFieldId") short ts_language_field_id_for_name(@Const TSLanguage arg0, @Cast("const char*") BytePointer arg1, @Cast("uint32_t") int arg2);
public static native @Cast("TSFieldId") short ts_language_field_id_for_name(@Const TSLanguage arg0, String arg1, @Cast("uint32_t") int arg2);

/**
 * Check whether the given node type id belongs to named nodes, anonymous nodes,
 * or a hidden nodes.
 *
 * See also {@code ts_node_is_named}. Hidden nodes are never returned from the API.
 */
public static native @Cast("TSSymbolType") int ts_language_symbol_type(@Const TSLanguage arg0, @Cast("uint16_t") short arg1);

/**
 * Get the ABI version number for this language. This version number is used
 * to ensure that languages were generated by a compatible version of
 * Tree-sitter.
 *
 * See also {@code ts_parser_set_language}.
 */
public static native @Cast("uint32_t") int ts_language_version(@Const TSLanguage arg0);

// #ifdef __cplusplus
// #endif

// #endif  // TREE_SITTER_API_H_


}
