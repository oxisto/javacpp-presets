// Targeted by JavaCPP version 1.5.7-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.treesitter;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.treesitter.global.treesitter.*;


@Properties(inherit = org.bytedeco.treesitter.presets.treesitter.class)
public class TSLexer extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public TSLexer() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public TSLexer(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public TSLexer(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public TSLexer position(long position) {
        return (TSLexer)super.position(position);
    }
    @Override public TSLexer getPointer(long i) {
        return new TSLexer((Pointer)this).offsetAddress(i);
    }

  public native int lookahead(); public native TSLexer lookahead(int setter);
  public native @Cast("uint16_t") short result_symbol(); public native TSLexer result_symbol(short setter);
  public static class Advance_TSLexer_boolean extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Advance_TSLexer_boolean(Pointer p) { super(p); }
      protected Advance_TSLexer_boolean() { allocate(); }
      private native void allocate();
      public native void call(TSLexer arg0, @Cast("bool") boolean arg1);
  }
  public native Advance_TSLexer_boolean advance(); public native TSLexer advance(Advance_TSLexer_boolean setter);
  public static class Mark_end_TSLexer extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Mark_end_TSLexer(Pointer p) { super(p); }
      protected Mark_end_TSLexer() { allocate(); }
      private native void allocate();
      public native void call(TSLexer arg0);
  }
  public native Mark_end_TSLexer mark_end(); public native TSLexer mark_end(Mark_end_TSLexer setter);
  public static class Get_column_TSLexer extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Get_column_TSLexer(Pointer p) { super(p); }
      protected Get_column_TSLexer() { allocate(); }
      private native void allocate();
      public native @Cast("uint32_t") int call(TSLexer arg0);
  }
  public native Get_column_TSLexer get_column(); public native TSLexer get_column(Get_column_TSLexer setter);
  public static class Is_at_included_range_start_TSLexer extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Is_at_included_range_start_TSLexer(Pointer p) { super(p); }
      protected Is_at_included_range_start_TSLexer() { allocate(); }
      private native void allocate();
      public native @Cast("bool") boolean call(@Const TSLexer arg0);
  }
  public native Is_at_included_range_start_TSLexer is_at_included_range_start(); public native TSLexer is_at_included_range_start(Is_at_included_range_start_TSLexer setter);
  public static class Eof_TSLexer extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Eof_TSLexer(Pointer p) { super(p); }
      protected Eof_TSLexer() { allocate(); }
      private native void allocate();
      public native @Cast("bool") boolean call(@Const TSLexer arg0);
  }
  public native Eof_TSLexer eof(); public native TSLexer eof(Eof_TSLexer setter);
}
